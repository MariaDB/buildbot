# -*- python -*-
# ex: set filetype=python:

import os
from collections import defaultdict

import yaml

from buildbot.plugins import steps, util
from buildbot.process.properties import Property
from common_factories import (
    getQuickBuildFactory,
    getRpmAutobakeFactory,
    getSourceTarball,
)
from constants import (
    GITHUB_STATUS_BUILDERS,
    OS_INFO,
    SAVED_PACKAGE_BRANCHES,
)
from locks import getLocks
from master_common import base_master_config
from utils import (
    canStartBuild,
    createDebRepo,
    createWorker,
    dockerfile,
    hasDockerLibrary,
    hasInstall,
    hasPackagesGenerated,
    hasUpgrade,
    ls2string,
    nextBuild,
    printEnv,
    savePackageIfBranchMatch,
    uploadDebArtifacts,
)

cfg_dir = os.path.abspath(os.path.dirname(__file__))
# Autogen master, see buildbot.tac for why this is the case.
base_dir = os.path.abspath(f"{cfg_dir}/../../")
with open(os.path.join(cfg_dir, "master-config.yaml"), "r") as file:
    master_config = yaml.safe_load(file)


# Load the slave, database passwords and 3rd-party tokens from an external
# private file, so that the rest of the configuration can be public.
config = {"private": {}}
with open(os.path.join(cfg_dir, "master-private.cfg"), "r") as file:
    exec(file.read(), config, {})

# This is the dictionary that the buildmaster pays attention to. We also use
# a shorter alias to save typing.
c = BuildmasterConfig = base_master_config(config)


#######
# DB URL
#######
mtrDbPool = util.EqConnectionPool(
    "MySQLdb",
    config["private"]["db_host"],
    config["private"]["db_user"],
    config["private"]["db_password"],
    config["private"]["db_mtr_db"],
)

#########
# WORKERS
#########

# The 'workers' list defines the set of recognized workers. Each element is
# a Worker object, specifying a unique worker name and password.  The same
# worker name and password must be configured on the worker.
c["workers"] = []

# Docker workers

workers = defaultdict(list)

# For each worker in master_config ['aarch64-bbw1', 2, 3, 4]
for w_name in master_config["workers"]:
    jobs = 7
    worker_name = w_name[:-1]  # aarch64-bbw
    worker_id = w_name[-1]     # 1, 2, 3, 4

    for arch in master_config["builders"]:
        builders = master_config["builders"][arch]
        for os_name in builders:
            os_definition = builders[os_name]
            image_tag = os_definition['image_tag']

            # Skip s390x non-SLES builders on SLES host (bbw2)
            if ("s390x" in arch
                    and (worker_id == "2")
                    and ("sles" not in os_name)):
                continue

            if image_tag.startswith("ubuntu"):
                image_tag = image_tag[:-2] + "." + image_tag[-2:]

            quay_name = f'{os.environ["CONTAINER_REGISTRY_URL"]}{image_tag}'
            if arch.startswith("x86"):
                os_name += "-i386"
                quay_name += "-386"

            base_name, name, worker_instance = createWorker(
                worker_name,
                worker_id,
                os_name,
                quay_name,
                jobs=jobs,
                save_packages=True,
                shm_size="15G",
            )

            workers[base_name].append(name)
            c["workers"].append(worker_instance)


####### FACTORY CODE

f_quick_build = getQuickBuildFactory("nm", mtrDbPool)
f_rpm_autobake = getRpmAutobakeFactory()

f_deb_autobake = util.BuildFactory()
f_deb_autobake.addStep(printEnv())
f_deb_autobake.addStep(
    steps.SetProperty(
        property="dockerfile",
        value=util.Interpolate("%(kw:url)s", url=dockerfile),
        description="dockerfile",
    )
)
f_deb_autobake.addStep(getSourceTarball())
# build steps
f_deb_autobake.addStep(
    steps.Compile(
        logfiles={"CMakeCache.txt": "./builddir/CMakeCache.txt"},
        command=["debian/autobake-deb.sh"],
        env={
            "CCACHE_DIR": "/mnt/ccache",
            "DEB_BUILD_OPTIONS": util.Interpolate(
                "parallel=%(kw:jobs)s",
                jobs=util.Property("jobs", default="$(getconf _NPROCESSORS_ONLN)"),
            ),
        },
        description="autobake-deb.sh",
    )
)
# upload artifacts
f_deb_autobake.addStep(
    steps.SetPropertyFromCommand(
        command="find .. -maxdepth 1 -type f", extract_fn=ls2string
    )
)
f_deb_autobake.addStep(createDebRepo())
f_deb_autobake.addStep(uploadDebArtifacts())

f_deb_autobake.addStep(
    steps.Trigger(
        name="dockerlibrary",
        schedulerNames=["s_dockerlibrary"],
        waitForFinish=False,
        updateSourceStamp=False,
        set_properties={
            "tarbuildnum": Property("tarbuildnum"),
            "mariadb_version": Property("mariadb_version"),
            "master_branch": Property("master_branch"),
            "parentbuildername": Property("buildername"),
        },
        doStepIf=lambda step: hasDockerLibrary(step),
    )
)
f_deb_autobake.addStep(
    steps.Trigger(
        name="release preparation",
        schedulerNames=["s_release_prep"],
        waitForFinish=True,
        updateSourceStamp=False,
        set_properties={
            "tarbuildnum": Property("tarbuildnum"),
            "mariadb_version": Property("mariadb_version"),
            "master_branch": Property("master_branch"),
            "parentbuildername": Property("buildername"),
        },
        doStepIf=(lambda step: savePackageIfBranchMatch(step, SAVED_PACKAGE_BRANCHES)),
    )
)
f_deb_autobake.addStep(
    steps.Trigger(
        name="install",
        schedulerNames=["s_install"],
        waitForFinish=False,
        updateSourceStamp=False,
        set_properties={
            "tarbuildnum": Property("tarbuildnum"),
            "mariadb_version": Property("mariadb_version"),
            "master_branch": Property("master_branch"),
            "parentbuildername": Property("buildername"),
        },
        doStepIf=(
            lambda step: hasInstall(step)
            and savePackageIfBranchMatch(step, SAVED_PACKAGE_BRANCHES)
            and hasPackagesGenerated(step)
        ),
    )
)
f_deb_autobake.addStep(
    steps.Trigger(
        name="major-minor-upgrade",
        schedulerNames=["s_upgrade"],
        waitForFinish=False,
        updateSourceStamp=False,
        set_properties={
            "tarbuildnum": Property("tarbuildnum"),
            "mariadb_version": Property("mariadb_version"),
            "master_branch": Property("master_branch"),
            "parentbuildername": Property("buildername"),
        },
        doStepIf=(
            lambda step: hasUpgrade(step)
            and savePackageIfBranchMatch(step, SAVED_PACKAGE_BRANCHES)
            and hasPackagesGenerated(step)
        ),
    )
)
f_deb_autobake.addStep(
    steps.ShellCommand(
        name="cleanup", command="rm -r * .* 2> /dev/null || true", alwaysRun=True
    )
)

####### BUILDERS LIST

c["builders"] = []

for arch in master_config["builders"]:
    builders_group = master_config["builders"][arch]
    for os_name in builders_group:
        worker_prefix = arch
        worker_suffix = ''

        if arch == "amd64":
            worker_prefix = "x64"

        if arch == "x86":
            worker_prefix = 'x64'
            worker_suffix = '-i386'
        worker_name = f'{worker_prefix}-bbw-docker-{os_name}{worker_suffix}'

        build_type = OS_INFO[os_name]["type"]

        builder = f'{arch}-{os_name}'

        tags = [os_name]
        # Add builder only if it's not a protected branches one
        if builder not in GITHUB_STATUS_BUILDERS:
            c["builders"].append(
                util.BuilderConfig(
                    name=builder,
                    workernames=workers[worker_name],
                    tags=tags,
                    collapseRequests=True,
                    nextBuild=nextBuild,
                    canStartBuild=canStartBuild,
                    locks=getLocks,
                    factory=f_quick_build,
                )
            )

        factory_instance = (
            f_deb_autobake if build_type != "rpm" else f_rpm_autobake
        )
        properties = {
            "verbose_build": "VERBOSE=1" if arch == "ppc4le" else None,
            "rpm_type": "".join(os_name.split("-")) if build_type == "rpm" else None
        }

        tags += [build_type, "autobake"]

        c["builders"].append(
            util.BuilderConfig(
                name=f"{builder}-{build_type}-autobake",
                workernames=workers[worker_name],
                tags=tags,
                collapseRequests=True,
                nextBuild=nextBuild,
                canStartBuild=canStartBuild,
                locks=getLocks,
                properties=properties,
                factory=factory_instance,
            )
        )
