# -*- python -*-
# ex: set filetype=python:

import os
import json

from buildbot.plugins import util, worker, steps


from constants import SAVED_PACKAGE_BRANCHES
from utils import getSourceTarball, read_template, savePackageIfBranchMatch
from master_common import base_master_config

cfg_dir = os.path.abspath(os.path.dirname(__file__))

# Non autogen master. For now the directory structure is:
# <srcdir>
# └── <master-name>
#     ├── buildbot.tac
#     └── master.cfg
#
# Non autogen masters load from <srcdir> for now.
base_dir = os.path.abspath(f'{cfg_dir}/../')

# Load the slave, database passwords and 3rd-party tokens from an external private file, so
# that the rest of the configuration can be public.
config = {"private": {}}
with open(os.path.join(base_dir, "master-private.cfg"), "r") as file:
    exec(file.read(), config, {})


# This is the dictionary that the buildmaster pays attention to. We also use
# a shorter alias to save typing.
c = BuildmasterConfig = base_master_config(
    config,
    master_port=os.environ["MASTER_NONLATENT_BINTARS_WORKER_PORT"])

mtrDbPool = util.EqConnectionPool(
    "MySQLdb",
    config["private"]["db_host"],
    config["private"]["db_user"],
    config["private"]["db_password"],
    config["private"]["db_mtr_db"],
)


#######
# WORKERS
#######
def mkWorker(name, **kwargs):
    return worker.Worker(name, config["private"]["worker_pass"][name], **kwargs)


# The 'workers' list defines the set of recognized workers. Each element is
# a Worker object, specifying a unique worker name and password.  The same
# worker name and password must be configured on the worker.

workers_bintar = json.loads(
    os.environ["MASTER_NONLATENT_BINTARS_WORKERS"]
)

c["workers"] = []

for k, v in workers_bintar.items():
    c["workers"].append(
        mkWorker(
            f"{k}",
            max_builds=v["max_builds"],
            properties={"jobs": v["jobs"]},
        )
    )


####### FACTORY CODE
def memory_def():
    # TODO Dummy implementation, replace with actual logic to define memory
    return "8192"


gccWarningPattern = "^(.*?):([0-9]+):(?:[0-9]+:)? [Ww]arning: (.*)$"
kvm_scpopt = "-o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -o PubkeyAcceptedKeyTypes=ssh-dss -o HostKeyAlgorithms=ssh-dss"


def ScpSourceIntoVM(port):
    return util.Interpolate(
        "= scp -P "
        + port
        + " "
        + kvm_scpopt
        + " ./packages/%(prop:mariadb_version)s.tar.gz buildbot@localhost:buildbot/build"
    )


def getMTR(**kwargs):
    return steps.MTR(
        dbpool=mtrDbPool,
        warningPattern="MTR's internal check of the test case '.*' failed|Failing test\(s\):.*|\*\*\*Warnings generated in error logs.*|Test warning:.*",
        **kwargs,
    )


def getBintarFactory(
    name,
    kvm_image,
    cpu,
    ramdisk=True,
    catg="main",
    suffix="",
    port="10000",
):
    bin_fact = util.BuildFactory()

    args = [
        "--port=" + port,
        "--memory=" + memory_def(),
        "--user=buildbot",
        "--cpu=" + cpu,
        "--smp=8",
        "--logfile=kernel_" + port + ".log",
    ]
    if ramdisk:
        args.append("--work-image=/dev/shm/vm-tmp-" + port + ".qcow2")

    kvm_image_test = kvm_image.replace("vm-centos5", "vm-centos6")

    # Step 1: Cleaning build directory
    bin_fact.addStep(
        steps.ShellCommand(
            description=["cleaning", "build", "dir"],
            command=["sh", "-c", "rm -Rf ../build/*"],
        )
    )

    # Step 2: Downloading source tarball (Adapt this to your source download mechanism)
    bin_fact.addStep(getSourceTarball())

    # Custom Compile Step
    # Step 5: Compile (Simplified example, adapt as needed)
    bin_fact.addStep(
        steps.Compile(
            description=["making", "bintar"],
            descriptionDone=["make", "bintar"],
            timeout=3600,
            logfiles={"kernel": "kernel_" + port + ".log"},
            warningPattern=gccWarningPattern,
            env={"TERM": "vt102"},
            command=["runvm"]
            + args
            + [
                "--base-image=/kvm/vms/" + kvm_image + "-build.qcow2",
                "vm-tmp-" + port + ".qcow2",
                "rm -Rf buildbot && mkdir -p buildbot/build",
                ScpSourceIntoVM(port),
                util.Interpolate(
                    "cd buildbot/build && tar -xzf %(prop:mariadb_version)s.tar.gz --strip-components=1 && rm %(prop:mariadb_version)s.tar.gz"
                ),
                util.Interpolate(read_template("bintar_compile")),
                util.Interpolate(
                    "= scp -P "
                    + port
                    + " "
                    + kvm_scpopt
                    + " 'buildbot@localhost:buildbot/build/mariadb-*.tar.gz' ."
                ),
                "= scp -P "
                + port
                + " "
                + kvm_scpopt
                + " buildbot@localhost:buildbot/bindistname.txt .",
            ],
        )
    )
    bin_fact.addStep(
        steps.SetPropertyFromCommand(
            command=["cat", "bindistname.txt"],
            property="bindistname",
        )
    )
    bin_fact.addStep(
        steps.ShellCommand(
            name="save_packages",
            timeout=7200,
            haltOnFailure=True,
            command=util.Interpolate(
                "mkdir -p "
                + "/packages/"
                + "%(prop:tarbuildnum)s"
                + "/"
                + "%(prop:buildername)s"
                + " && sha256sum %(prop:bindistname)s >> sha256sums.txt  && cp "
                + "%(prop:bindistname)s sha256sums.txt"
                + " /packages/"
                + "%(prop:tarbuildnum)s"
                + "/"
                + "%(prop:buildername)s"
                + "/"
                + " && sync /packages/"
                + "%(prop:tarbuildnum)s"
            ),
            doStepIf=(
                lambda step: savePackageIfBranchMatch(step, SAVED_PACKAGE_BRANCHES)
            ),
        )
    )

    bin_fact.addStep(
        getMTR(
            name="mtr",
            description=["testing", "bintar"],
            descriptionDone=["test", "bintar"],
            logfiles={"kernel": "kernel_" + port + ".log"},
            mtr_subdir=".",  # Where we scp vardir to
            env={"TERM": "vt102"},
            command=["runvm"]
            + args
            + [
                "--base-image=/kvm/vms/" + kvm_image_test + "-install.qcow2",
                "vm-tmp-" + port + ".qcow2",
                "rm -Rf buildbot && mkdir buildbot",
                util.Interpolate(
                    "= scp -P "
                    + port
                    + " "
                    + kvm_scpopt
                    + " %(prop:bindistname)s.tar.gz buildbot@localhost:buildbot/"
                ),
                util.Interpolate(read_template("bintar_mtr")),
                util.Interpolate(
                    "! sudo chmod -R go+rX /usr/local/%(prop:bindistname)s/mysql-test/var/ || :"
                ),
                util.Interpolate(
                    "!= scp -rp -P "
                    + port
                    + " "
                    + kvm_scpopt
                    + " buildbot@localhost:/usr/local/%(prop:bindistname)s/mysql-test/var/ . || :"
                ),
            ],
        )
    )

    bin_fact.addStep(
        getMTR(
            name="mtr-rocksdb",
            description=["testing", "rocksdb"],
            descriptionDone=["test", "rocksdb"],
            logfiles={"kernel": "kernel_" + port + ".log"},
            mtr_subdir=".",  # Where we scp vardir to
            env={"TERM": "vt102"},
            command=["runvm"]
            + args
            + [
                "vm-tmp-" + port + ".qcow2",
                util.Interpolate(read_template("bintar_mtr_rocksdb")),
                util.Interpolate(
                    "! sudo chmod -R go+rX /usr/local/%(prop:bindistname)s/mysql-test/var/ || :"
                ),
                util.Interpolate(
                    "!= scp -rp -P "
                    + port
                    + " "
                    + kvm_scpopt
                    + " buildbot@localhost:/usr/local/%(prop:bindistname)s/mysql-test/var/ . || :"
                ),
            ],
        )
    )

    return bin_fact


####### BUILDERS LIST
c["builders"] = []

builder_definitions = {
    "ubuntu-1604": "trusty",
    "centos-6": "centos6",
}

current_port = int(os.environ["MASTER_NONLATENT_BINTARS_VM_PORT"])

for b in builder_definitions:
    for arch in ["amd64", "i386"]:
        if arch == "i386":
            builder_name = "x86"
        else:
            builder_name = arch

    f = getBintarFactory(
        name=builder_name + "-kvm-" + b + "-bintar",
        kvm_image="vm-" + builder_definitions[b] + "-" + arch,
        cpu="host",
        ramdisk=False,
        port=str(current_port),
    )
    current_port += 1

    c["builders"].append(
        util.BuilderConfig(
            name=builder_name + "-kvm-" + b + "-bintar",
            workernames=[*workers_bintar],
            factory=f,
        )
    )
